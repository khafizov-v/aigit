# Commit Details: 44761c3b

**Repository:** [qf-solochain](https://github.com/QuantumFusion-network/qf-solochain)
**Author:** Alekseev Svyatoslav (zotho)
**Date:** 2025-06-05 08:44:05+00:00
**Branch(es):** main
**Commit Link:** [View on GitHub](https://github.com/QuantumFusion-network/qf-solochain/commit/44761c3b6b8f8d7cc66b17a9d19e47dea56ff132)

## Commit Message
```
Merge pull request #95 from QuantumFusion-network/zotho/issue-346

Enable `print` host function in PVM
```

## Statistics
- **Files changed:** 8
- **Lines added:** 129
- **Lines deleted:** 78
- **Total changes:** 207

## File Changes

### ✏️ .github/workflows/checks.yml (modified)
**Changes:** +4 -0

```diff
@@ -54,3 +54,7 @@ jobs:
       - name: Check code
         run: |
           cargo check --locked --all
+
+      - name: Tests
+        run: |
+          cargo test -p pallet-qf-polkavm
```

### ✏️ Cargo.lock (modified)
**Changes:** +2 -0

```diff
@@ -9175,6 +9175,8 @@ dependencies = [
  "image",
  "libc",
  "log",
+ "num-derive",
+ "num-traits",
  "pallet-balances",
  "parity-scale-codec",
  "paste",
```

### ✏️ pallets/qf-polkavm/Cargo.toml (modified)
**Changes:** +2 -0

```diff
@@ -13,6 +13,8 @@ publish = false
 targets = ["x86_64-unknown-linux-gnu"]
 
 [dependencies]
+num-traits = { version = "0.2.19", default-features = false }
+num-derive = "0.4.2"
 codec = { features = [
 	"derive",
 ], workspace = true }
```

### ✏️ pallets/qf-polkavm/src/lib.rs (modified)
**Changes:** +114 -31

```diff
@@ -70,6 +70,8 @@ pub mod pallet {
 		},
 	};
 	use frame_system::pallet_prelude::*;
+	use num_derive::{FromPrimitive, ToPrimitive};
+	use num_traits::ToPrimitive;
 	use scale_info::{TypeInfo, prelude::vec::Vec};
 	use sp_runtime::traits::{Hash, SaturatedConversion, TrailingZeroInput};
 
@@ -151,6 +153,9 @@ pub mod pallet {
 		#[pallet::constant]
 		type MaxStorageKeySize: Get<u32>;
 
+		#[pallet::constant]
+		type MaxLogLen: Get<u32>;
+
 		#[pallet::constant]
 		type MinGasPrice: Get<u64>;
 
@@ -378,24 +383,28 @@ pub mod pallet {
 				.checked_sub(1)
 				.ok_or(Error::<T>::IntegerOverflow)?;
 
+			let max_log_len = <T as Config>::MaxLogLen::get()
+				.try_into()
+				.map_err(|_| Error::<T>::IntegerOverflow)?;
+
 			let (raw_blob, version) = Code::<T>::get(&contract_address)
 				.map(|(blob, version)| (blob.into_inner(), version))
 				.ok_or(Error::<T>::ProgramBlobNotFound)?;
 
 			let mut instance = Self::instantiate(Self::prepare(raw_blob)?)?;
 			instance.set_gas(gas_before.into());
 
-			let mut state = State::new(
-				[contract_address.clone(), who.clone()].to_vec(),
-				[104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, 33, 33].to_vec(),
+			let mut state = State {
+				addresses: [contract_address.clone(), who.clone()].to_vec(),
 				data,
-				[].to_vec(),
-				BTreeMap::new(),
-				version,
+				mutating_operations: [].to_vec(),
+				raw_storage: BTreeMap::new(),
+				code_version: version,
 				max_storage_size,
 				max_storage_key_size,
 				max_storage_slot_idx,
-				|from: T::AccountId, to: T::AccountId, value: u32| -> u64 {
+				max_log_len,
+				transfer: |from: T::AccountId, to: T::AccountId, value: u32| -> u64 {
 					if !value.is_zero() && from != to {
 						if let Err(_) =
 							T::Currency::transfer(&from, &to, value.into(), Preservation::Preserve)
@@ -405,25 +414,31 @@ pub mod pallet {
 					}
 					0
 				},
-				|m: Vec<u8>| -> u64 {
-					sp_runtime::print(&*m);
+				print: |m: Vec<u8>| -> u64 {
+					let msg = alloc::string::String::from_utf8_lossy(&m);
+					let msg_log = alloc::format!("polkavm: {msg}");
+					sp_runtime::print(msg_log.as_str());
 					return 0;
 				},
-				|address: T::AccountId| -> u64 { T::Currency::balance(&address).saturated_into() },
-				|| -> u64 { frame_system::Pallet::<T>::block_number().saturated_into() },
-				|| -> u64 { 0 },
-				|| -> u64 { 1 },
-				|contract_address: T::AccountId,
-				 version: CodeVersion,
-				 key: StorageKey<T>|
+				balance: |address: T::AccountId| -> u64 {
+					T::Currency::balance(&address).saturated_into()
+				},
+				block_number: || -> u64 {
+					frame_system::Pallet::<T>::block_number().saturated_into()
+				},
+				account_id: || -> u64 { 0 },
+				caller: || -> u64 { 1 },
+				get: |contract_address: T::AccountId,
+				      version: CodeVersion,
+				      key: StorageKey<T>|
 				 -> Option<Vec<u8>> {
 					CodeStorage::<T>::get((contract_address, version, key)).map(|d| d.to_vec())
 				},
-				|contract_address: T::AccountId,
-				 version: CodeVersion,
-				 key: StorageKey<T>,
-				 max_storage_size: usize,
-				 mut data: Vec<u8>|
+				insert: |contract_address: T::AccountId,
+				         version: CodeVersion,
+				         key: StorageKey<T>,
+				         max_storage_size: usize,
+				         mut data: Vec<u8>|
 				 -> u64 {
 					let mut buffer = BoundedVec::with_bounded_capacity(max_storage_size);
 					if let Ok(_) = buffer.try_append(&mut data) {
@@ -433,11 +448,14 @@ pub mod pallet {
 						1
 					}
 				},
-				|contract_address: T::AccountId, version: CodeVersion, key: StorageKey<T>| -> u64 {
+				delete: |contract_address: T::AccountId,
+				         version: CodeVersion,
+				         key: StorageKey<T>|
+				 -> u64 {
 					CodeStorage::<T>::remove((contract_address, version, key));
 					0
 				},
-			);
+			};
 
 			sp_runtime::print("====== BEFORE CALL ======");
 
@@ -517,16 +535,32 @@ pub mod pallet {
 		}
 
 		fn instantiate(module: PolkaVMModule) -> Result<Instance<T>, DispatchError> {
+			#[derive(Debug, FromPrimitive, ToPrimitive)]
+			enum HostFunctionError {
+				MaxLogLenExceeded = 1005,
+				FailedToReadLogBuffer = 1006,
+				IndexOutOfBounds = 1007,
+				FailedToWriteVmMemory = 1008,
+			}
+
 			// High-level API.
 			let mut linker: Linker<T> = Linker::<T>::new();
 
 			linker
 				.define_typed("transfer", |caller: Caller<T>, balance: u32| -> u64 {
-					(caller.user_data.transfer)(
-						caller.user_data.addresses[0].clone(),
-						caller.user_data.addresses[1].clone(),
-						balance,
-					)
+					let from = match caller.user_data.addresses.get(0) {
+						Some(from) => from.clone(),
+						None =>
+							return HostFunctionError::IndexOutOfBounds.to_u64().expect("a number"),
+					};
+
+					let to = match caller.user_data.addresses.get(1) {
+						Some(to) => to.clone(),
+						None =>
+							return HostFunctionError::IndexOutOfBounds.to_u64().expect("a number"),
+					};
+
+					(caller.user_data.transfer)(from, to, balance)
 				})
 				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
 
@@ -543,8 +577,21 @@ pub mod pallet {
 				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
 
 			linker
-				.define_typed("print", |caller: Caller<T>| -> u64 {
-					(caller.user_data.print)(caller.user_data.log_message.clone())
+				.define_typed("print", |caller: Caller<T>, msg_pointer: u32, len: u32| -> u64 {
+					let user_data = caller.user_data;
+					if len as usize > user_data.max_log_len {
+						return HostFunctionError::MaxLogLenExceeded.to_u64().expect("a number");
+					}
+
+					let raw_data = match caller.instance.read_memory(msg_pointer, len) {
+						Ok(raw_data) => raw_data,
+						Err(_) =>
+							return HostFunctionError::FailedToReadLogBuffer
+								.to_u64()
+								.expect("a number"),
+					};
+
+					(user_data.print)(raw_data)
 				})
 				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
 
@@ -570,10 +617,46 @@ pub mod pallet {
 				})
 				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
 
+			linker
+				.define_typed("get_address_len", |caller: Caller<T>, address_idx: u32| -> u64 {
+					let address = match caller.user_data.addresses.get(address_idx as usize) {
+						Some(address) => address.clone(),
+						None =>
+							return HostFunctionError::IndexOutOfBounds.to_u64().expect("a number"),
+					};
+					let raw_data: Vec<u8> = address.encode();
+
+					raw_data.len() as u64
+				})
+				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
+
+			linker
+				.define_typed(
+					"get_address",
+					|caller: Caller<T>, address_idx: u32, write_pointer: u32| -> u64 {
+						let address = match caller.user_data.addresses.get(address_idx as usize) {
+							Some(address) => address.clone(),
+							None =>
+								return HostFunctionError::IndexOutOfBounds
+									.to_u64()
+									.expect("a number"),
+						};
+						let raw_data: Vec<u8> = address.encode();
+
+						match caller.instance.write_memory(write_pointer, &raw_data) {
+							Err(_) =>
+								HostFunctionError::FailedToWriteVmMemory.to_u64().expect("a number"),
+							Ok(_) => 0,
+						}
+					},
+				)
+				.map_err(|_| Error::<T>::HostFunctionDefinitionFailed)?;
+
 			linker
 				.define_typed("get_user_data", |caller: Caller<T>, pointer: u32| -> u64 {
 					match caller.instance.write_memory(pointer, &caller.user_data.data) {
-						Err(_) => 1000,
+						Err(_) =>
+							HostFunctionError::FailedToWriteVmMemory.to_u64().expect("a number"),
 						Ok(_) => 0,
 					}
 				})
```

### ✏️ pallets/qf-polkavm/src/mock.rs (modified)
**Changes:** +2 -0

```diff
@@ -58,6 +58,7 @@ parameter_types! {
 	pub const PolkaVmMaxGasLimit: u32 = 2097152;
 	pub const PolkaVmMaxStorageKeySize: u32 = 256;
 	pub const PolkaVmMaxStorageSlots: u32 = 4;
+	pub const PolkaVmMaxLogLen: u32 = 1024;
 	pub const PolkaVmMinGasPrice: u64 = 1;
 	pub const PolkaVmMinStorageDepositLimit: u64 = 1;
 	pub const PolkaVmStorageSize: u32 = 2048;
@@ -72,6 +73,7 @@ impl pallet::Config for Test {
 	type MaxGasLimit = PolkaVmMaxGasLimit;
 	type MaxStorageKeySize = PolkaVmMaxStorageKeySize;
 	type MaxStorageSlots = PolkaVmMaxStorageSlots;
+	type MaxLogLen = PolkaVmMaxLogLen;
 	type MinGasPrice = PolkaVmMinGasPrice;
 	type MinStorageDepositLimit = PolkaVmMinStorageDepositLimit;
 	type StorageSize = PolkaVmStorageSize;
```

### ✏️ pallets/qf-polkavm/src/polkavm/linker.rs (modified)
**Changes:** +1 -45

```diff
@@ -594,14 +594,14 @@ where
 
 pub struct State<T: PalletConfig> {
 	pub addresses: Vec<T::AccountId>,
-	pub log_message: Vec<u8>,
 	pub data: Vec<u8>,
 	pub mutating_operations: Vec<MutatingStorageOperation<T>>,
 	pub raw_storage: BTreeMap<CodeStorageKey<T>, Option<CodeStorageSlot<T>>>,
 	pub code_version: CodeVersion,
 	pub max_storage_size: usize,
 	pub max_storage_key_size: u32,
 	pub max_storage_slot_idx: u32,
+	pub max_log_len: usize,
 	pub transfer: fn(T::AccountId, T::AccountId, u32) -> u64,
 	pub print: fn(Vec<u8>) -> u64,
 	pub balance: fn(T::AccountId) -> u64,
@@ -613,50 +613,6 @@ pub struct State<T: PalletConfig> {
 	pub delete: fn(T::AccountId, version: CodeVersion, StorageKey<T>) -> u64,
 }
 
-impl<T: PalletConfig> State<T> {
-	pub fn new(
-		addresses: Vec<T::AccountId>,
-		log_message: Vec<u8>,
-		data: Vec<u8>,
-		mutating_operations: Vec<MutatingStorageOperation<T>>,
-		raw_storage: BTreeMap<CodeStorageKey<T>, Option<CodeStorageSlot<T>>>,
-		code_version: CodeVersion,
-		max_storage_size: usize,
-		max_storage_key_size: u32,
-		max_storage_slot_idx: u32,
-		transfer: fn(T::AccountId, T::AccountId, u32) -> u64,
-		print: fn(Vec<u8>) -> u64,
-		balance: fn(T::AccountId) -> u64,
-		block_number: fn() -> u64,
-		account_id: fn() -> u64,
-		caller: fn() -> u64,
-		get: fn(T::AccountId, CodeVersion, StorageKey<T>) -> Option<Vec<u8>>,
-		insert: fn(T::AccountId, CodeVersion, StorageKey<T>, usize, Vec<u8>) -> u64,
-		delete: fn(T::AccountId, CodeVersion, StorageKey<T>) -> u64,
-	) -> Self {
-		Self {
-			addresses,
-			log_message,
-			data,
-			mutating_operations,
-			raw_storage,
-			code_version,
-			max_storage_size,
-			max_storage_key_size,
-			max_storage_slot_idx,
-			transfer,
-			print,
-			balance,
-			block_number,
-			account_id,
-			caller,
-			get,
-			insert,
-			delete,
-		}
-	}
-}
-
 #[non_exhaustive]
 pub struct Caller<'a, T: PalletConfig> {
 	pub user_data: &'a mut State<T>,
```

### ✏️ pallets/qf-polkavm/src/tests.rs (modified)
**Changes:** +2 -2

```diff
@@ -122,7 +122,7 @@ fn inc_should_work() {
 		System::set_block_number(1);
 		upload();
 
-		assert_eq!(CodeStorage::<Test>::get((CONTRACT_ADDRESS, VERSION, key::<Test>())), None,);
+		assert_eq!(CodeStorage::<Test>::get((CONTRACT_ADDRESS, VERSION, key::<Test>())), None);
 
 		assert_ok!(QfPolkaVM::execute(
 			RuntimeOrigin::signed(BOB),
@@ -204,7 +204,7 @@ fn delete_should_work() {
 		System::set_block_number(1);
 		upload();
 
-		assert_eq!(CodeStorage::<Test>::get((CONTRACT_ADDRESS, VERSION, key::<Test>())), None,);
+		assert_eq!(CodeStorage::<Test>::get((CONTRACT_ADDRESS, VERSION, key::<Test>())), None);
 
 		assert_ok!(QfPolkaVM::execute(
 			RuntimeOrigin::signed(BOB),
```

### ✏️ runtimes/qf-runtime/src/configs/mod.rs (modified)
**Changes:** +2 -0

```diff
@@ -308,6 +308,7 @@ parameter_types! {
 	pub const PolkaVmMaxGasLimit: u64 = 2097152;
 	pub const PolkaVmMaxStorageKeySize: u32 = 256;
 	pub const PolkaVmMaxStorageSlots: u32 = 4;
+	pub const PolkaVmMaxLogLen: u32 = 1024;
 	pub const PolkaVmMinGasPrice: u64 = 1;
 	pub const PolkaVmMinStorageDepositLimit: u64 = 0;
 	pub const PolkaVmStorageSize: u32 = 2048;
@@ -322,6 +323,7 @@ impl pallet_qf_polkavm::Config for Runtime {
 	type MaxGasLimit = PolkaVmMaxGasLimit;
 	type MaxStorageKeySize = PolkaVmMaxStorageKeySize;
 	type MaxStorageSlots = PolkaVmMaxStorageSlots;
+	type MaxLogLen = PolkaVmMaxLogLen;
 	type MinGasPrice = PolkaVmMinGasPrice;
 	type MinStorageDepositLimit = PolkaVmMinStorageDepositLimit;
 	type StorageSize = PolkaVmStorageSize;
```
